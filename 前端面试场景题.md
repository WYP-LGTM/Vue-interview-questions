# 前端场景题
## 一、SPA首屏加载速度慢的怎么解决
### SPA首屏加载从5s优化到1s内，你会怎么做？
* 首屏性能优化需从资源加载、渲染路径、架构设计三方面切入
  * 1. 资源体积压缩（核心瓶颈）
     * 代码分割：路由级懒加载（React.lazy + Suspense） + 组件级动态导入（减少主包30%~50%）
     * 资源优化：
        * 图片转WebP并CDN分发（体积降40%）
        * 字体图标替代图片，关键CSS内联
        * 第三方库按需引入（如lodash-es替代lodash）
   * 2.  渲染提速
        *  流式SSR：Node.js分块输出HTML（React：renderToNodeStream），使首屏内容快速到达
        *  边缘计算：将SSR部署至CDN边缘节点（Vercel Edge Functions），降低网络延迟
        *  占位策略：骨架屏 + 图片懒加载（Intersection Observer API）、
   * 3. 网络与缓存优化
        * HTTP/2多路复用 + 资源预加载（<link rel="preload">）
        * Service Worker缓存静态资源，支持离线访问
        * 长期缓存：文件名添加contenthash（Webpack配置）
   * 4.  性能监测
        *  Lighthouse分析FCP/FID指标，Webpack Bundle Analyzer诊断包依赖
        *  线上监控：RUM（Real User Monitoring）采集3G网络/低端机数据
## 二、如果有100个请求，你如何使用Promise控制并发?
### 对于问题的解析-对问题的理解
当需要同时处理100个异步请求时，直接使用Promise.all会一次性发起所有请求，可能导致服务器过载或浏览器资源耗尽。我们需要实现一个并发控制机制，确保同时只有指定数量的请求在执行。
### 怎么来解决这个问题
* 在JavaScript中可以通过 Promise.all()、Promise.race()、async/await等不同方式来实现对异步并发任务的控制。
* 核心思路
  * 1.创建一个并发池--最大并发数
  * 2.动态添加请求到并发池
  * 3.当有请求完成时，从等待队列取出新请求执行
  * 4.所有请求完成后返回结果
### 示例代码
```
/**
 * 控制并发请求的函数
 * @param {Array} requests - 返回Promise的函数数组
 * @param {number} maxConcurrent - 最大并发数
 * @returns {Promise<Array>} - 包含所有请求结果的数组
 */
function concurrentControl(requests, maxConcurrent) {
  return new Promise((resolve) => {
    const results = new Array(requests.length); // 存储结果
    let completedCount = 0; // 已完成请求数
    let activeCount = 0;    // 当前活跃请求数
    let index = 0;          // 当前请求索引
    
    // 执行单个请求
    function run() {
      // 所有请求已完成
      if (completedCount === requests.length) {
        resolve(results);
        return;
      }
      
      // 并发池未满且有等待请求
      while (activeCount < maxConcurrent && index < requests.length) {
        const currentIndex = index; // 保存当前索引
        const request = requests[index];
        index++;
        activeCount++;
        
        // 执行请求并处理结果
        request()
          .then((res) => {
            results[currentIndex] = res;
          })
          .catch((err) => {
            results[currentIndex] = err;
          })
          .finally(() => {
            activeCount--;
            completedCount++;
            run(); // 完成一个请求后尝试执行下一个
          });
      }
    }
    
    run(); // 启动初始请求
  });
}
```
### 代码使用示例
```
// 模拟100个请求
const requests = [];
for (let i = 1; i <= 100; i++) {
  requests.push(() => {
    // 模拟不同延迟的请求
    const delay = Math.random() * 2000 + 500;
    return new Promise(resolve => {
      setTimeout(() => {
        console.log(`请求 ${i} 完成，耗时 ${delay.toFixed(0)}ms`);
        resolve(`结果 ${i}`);
      }, delay);
    });
  });
}

// 控制并发数为5
concurrentControl(requests, 5)
  .then(results => {
    console.log('所有请求完成：', results);
  });
```
### 实现原理
1.并发池管理:使用activeCount跟踪当前执行中的请求数量,使用maxConcurrent限制最大并发数 2.请求调度机制：当并发池有空位时，立即添加新请求,每个请求完成后，自动触发新请求加入 3.结果处理：使用闭包保存每个请求的索引位置,确保结果数组顺序与原始请求顺序一致 4.完成检测：通过completedCount跟踪已完成请求数量,当完成数等于总请求数时，返回最终结果
### 第三方库
例如 async.js 和 p-limit 等。 p-limit 是一个专门用于控制 Promise并发的小型库。可以在 p-limit 文档中找到更多信息和示例。
### 实现Promise并发控制的关键点
* 动态调度机制：在请求完成时立即启动新请求
* 精确的状态跟踪：维护活跃请求数和完成请求数
* 结果顺序保证：通过闭包保存原始索引位置
* 结果顺序保证：通过闭包保存原始索引位置
### 在面试中回答此问题时，应重点说明：
* 并发控制的必要性-避免服务器过载/资源耗尽
* 实现方案的核心思路-池化技术+动态调度
* 关键状态变量的作用-activeCount, completedCount
* 实际应用场景-图片批量上传、大数据分页加载等
### 如果想要面试高级前端工程所需要掌握
解决 100 个请求的并发控制，绝不仅仅是写一个简单的循环或递归。作为高级工程师，我会设计一个功能完备、健壮可靠、可配置可观测的异步任务调度器。它基于动态调度池的核心思想，并融入优先级、重试、超时、取消、进度反馈甚至自适应并发等高级特性，同时注重模块化、可测试性和生产环境监控。这样的方案才能真正应对复杂应用的挑战，保证系统的稳定性和用户体验。
### Promise并发控制的专业回答
* 系统设计
* 工程实践
* 性能优化
