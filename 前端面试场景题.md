# 前端场景题
## 一、SPA首屏加载速度慢的怎么解决
### SPA首屏加载从5s优化到1s内，你会怎么做？
* 首屏性能优化需从资源加载、渲染路径、架构设计三方面切入
  * 1. 资源体积压缩（核心瓶颈）
     * 代码分割：路由级懒加载（React.lazy + Suspense） + 组件级动态导入（减少主包30%~50%）
     * 资源优化：
        * 图片转WebP并CDN分发（体积降40%）
        * 字体图标替代图片，关键CSS内联
        * 第三方库按需引入（如lodash-es替代lodash）
   * 2.  渲染提速
        *  流式SSR：Node.js分块输出HTML（React：renderToNodeStream），使首屏内容快速到达
        *  边缘计算：将SSR部署至CDN边缘节点（Vercel Edge Functions），降低网络延迟
        *  占位策略：骨架屏 + 图片懒加载（Intersection Observer API）、
   * 3. 网络与缓存优化
        * HTTP/2多路复用 + 资源预加载（<link rel="preload">）
        * Service Worker缓存静态资源，支持离线访问
        * 长期缓存：文件名添加contenthash（Webpack配置）
   * 4.  性能监测
        *  Lighthouse分析FCP/FID指标，Webpack Bundle Analyzer诊断包依赖
        *  线上监控：RUM（Real User Monitoring）采集3G网络/低端机数据
## 二、如果有100个请求，你如何使用Promise控制并发?
### 对于问题的解析-对问题的理解
当需要同时处理100个异步请求时，直接使用Promise.all会一次性发起所有请求，可能导致服务器过载或浏览器资源耗尽。我们需要实现一个并发控制机制，确保同时只有指定数量的请求在执行。
### 怎么来解决这个问题
* 在JavaScript中可以通过 Promise.all()、Promise.race()、async/await等不同方式来实现对异步并发任务的控制。
* 核心思路
  * 1.创建一个并发池--最大并发数
  * 2.动态添加请求到并发池
  * 3.当有请求完成时，从等待队列取出新请求执行
  * 4.所有请求完成后返回结果
### 示例代码
```
/**
 * 控制并发请求的函数
 * @param {Array} requests - 返回Promise的函数数组
 * @param {number} maxConcurrent - 最大并发数
 * @returns {Promise<Array>} - 包含所有请求结果的数组
 */
function concurrentControl(requests, maxConcurrent) {
  return new Promise((resolve) => {
    const results = new Array(requests.length); // 存储结果
    let completedCount = 0; // 已完成请求数
    let activeCount = 0;    // 当前活跃请求数
    let index = 0;          // 当前请求索引
    
    // 执行单个请求
    function run() {
      // 所有请求已完成
      if (completedCount === requests.length) {
        resolve(results);
        return;
      }
      
      // 并发池未满且有等待请求
      while (activeCount < maxConcurrent && index < requests.length) {
        const currentIndex = index; // 保存当前索引
        const request = requests[index];
        index++;
        activeCount++;
        
        // 执行请求并处理结果
        request()
          .then((res) => {
            results[currentIndex] = res;
          })
          .catch((err) => {
            results[currentIndex] = err;
          })
          .finally(() => {
            activeCount--;
            completedCount++;
            run(); // 完成一个请求后尝试执行下一个
          });
      }
    }
    
    run(); // 启动初始请求
  });
}
```
### 代码使用示例
```
// 模拟100个请求
const requests = [];
for (let i = 1; i <= 100; i++) {
  requests.push(() => {
    // 模拟不同延迟的请求
    const delay = Math.random() * 2000 + 500;
    return new Promise(resolve => {
      setTimeout(() => {
        console.log(`请求 ${i} 完成，耗时 ${delay.toFixed(0)}ms`);
        resolve(`结果 ${i}`);
      }, delay);
    });
  });
}

// 控制并发数为5
concurrentControl(requests, 5)
  .then(results => {
    console.log('所有请求完成：', results);
  });
```
### 实现原理
1.并发池管理:使用activeCount跟踪当前执行中的请求数量,使用maxConcurrent限制最大并发数 2.请求调度机制：当并发池有空位时，立即添加新请求,每个请求完成后，自动触发新请求加入 3.结果处理：使用闭包保存每个请求的索引位置,确保结果数组顺序与原始请求顺序一致 4.完成检测：通过completedCount跟踪已完成请求数量,当完成数等于总请求数时，返回最终结果
### 第三方库
例如 async.js 和 p-limit 等。 p-limit 是一个专门用于控制 Promise并发的小型库。可以在 p-limit 文档中找到更多信息和示例。
### 实现Promise并发控制的关键点
* 动态调度机制：在请求完成时立即启动新请求
* 精确的状态跟踪：维护活跃请求数和完成请求数
* 结果顺序保证：通过闭包保存原始索引位置
* 结果顺序保证：通过闭包保存原始索引位置
### 在面试中回答此问题时，应重点说明：
* 并发控制的必要性-避免服务器过载/资源耗尽
* 实现方案的核心思路-池化技术+动态调度
* 关键状态变量的作用-activeCount, completedCount
* 实际应用场景-图片批量上传、大数据分页加载等
### 如果想要面试高级前端工程所需要掌握
解决 100 个请求的并发控制，绝不仅仅是写一个简单的循环或递归。作为高级工程师，我会设计一个功能完备、健壮可靠、可配置可观测的异步任务调度器。它基于动态调度池的核心思想，并融入优先级、重试、超时、取消、进度反馈甚至自适应并发等高级特性，同时注重模块化、可测试性和生产环境监控。这样的方案才能真正应对复杂应用的挑战，保证系统的稳定性和用户体验。
### Promise并发控制的专业回答
* 系统设计
* 工程实践
* 性能优化
# 三、面试官问sessionStorage 能在多个标签页之间共享数据吗?
## sessionStorage能在多个标签页之间共享数据吗?
在回答这个问题之前我们先来聊聊另一个存储APl localstorage
只读的 localstorage 属性允许你访问一个 Document源(origin)的对象Storage ;存储的数据将保存在浏览器会话中。localstorage 类似 sessionstorage，但其区别在于:存储在1ocalstorage的数据可以长期保留;而当页面会话结束--也就是说，当页面被关闭时，存储在 sessionstorage 的数据会被清除。
### sessionStorage的底层机制

浏览器实例 ---> 标签1 --- >sessionStorage独立的存储桶 / ---> 标签2 --- >sessionStorage独立的存储桶
### 核心特性
localstorage
* 作用域--同源域名全局
* 数据共享--跨同源标签页
* 生命周期--永久存储
* 存储限制--通常5MB
* 数据同步--可通过storage事件同步

sessionStorage

* 作用域--单标签页级别
* 数据共享--仅限当前标签页
* 生命周期--标签页关闭即销毁
* 存储限制--通常5MB
* 数据同步--	无跨页同步机制
### 实现多标签页通信的解决方案
* LocalStorage + Storage 事件
原理：利用LocalStorage的全局性和storage事件广播
```
// 发送方标签页
function broadcastData(data) {
  localStorage.setItem('sharedData', JSON.stringify(data));
}

// 接收方标签页
window.addEventListener('storage', (event) => {
  if (event.key === 'sharedData') {
    const data = JSON.parse(event.newValue);
    console.log('收到数据:', data);
    
    // 处理数据后立即清理（可选）
    localStorage.removeItem('sharedData');
  }
});
```
* Broadcast Channel API---现代浏览器
原理：专门的跨标签页通信API
```
// 发送方
const channel = new BroadcastChannel('app-channel');
channel.postMessage({ type: 'dataUpdate', payload: data });

// 接收方
const channel = new BroadcastChannel('app-channel');
channel.onmessage = (event) => {
  console.log('收到广播:', event.data);
};
```
* SharedWorker 数据中转
原理：通过后台线程共享数据
```
// shared-worker.js
const connections = [];
onconnect = (e) => {
  const port = e.ports[0];
  connections.push(port);
  
  port.onmessage = (event) => {
    connections.forEach(conn => {
      if (conn !== port) conn.postMessage(event.data);
    });
  };
};

// 页面中使用
const worker = new SharedWorker('shared-worker.js');
worker.port.onmessage = (event) => {
  console.log('收到共享数据:', event.data);
};

// 发送数据
worker.port.postMessage({ key: 'theme', value: 'dark' });
```
### 安全与性能注意事项
安全防护要点
* 来源验证：所有跨页通信必须校验消息来源
* 数据消毒：严格验证传入数据结构
* 敏感数据加密：对token等敏感信息使用AES加密
性能优化建议
* 节流控制：高频数据更新使用节流
* 数据压缩：大型数据使用LZString压缩
* 差异更新：仅发送变化数据而非全量数据
### 问题回答
sessionStorage不能在多个窗口或标签页之间共享数据，但是当通过 window.open 或链接打开新页面时(不能是新窗口)，新页面会复制前一页的sessionStorage.
### 高级前端建议
对于关键业务数据共享，推荐使用BroadcastChannel API（兼容性允许时）或Redux+WebSocket的专业状态管理方案，避免直接依赖存储API实现核心业务逻辑同步。
# 四、面试官问扫码登录实现方式
## 扫码登录技术实现深度解析
扫码登录核心原理
用户打开登录页面-->生成二维码-->用户扫码-->手机确认-->网页获取凭证-->登录成功
流程时序图
<img width="732" height="658" alt="image" src="https://github.com/user-attachments/assets/c0de3848-678b-48be-b847-e12879c70432" />

核心组件实现方案
```
// 服务端生成二维码
const generateQRCode = async () => {
  const qrId = uuidv4(); // 生成唯一ID
  const expiresAt = Date.now() + 300000; // 5分钟有效期
  const signature = crypto.createHmac('sha256', SECRET)
                         .update(`${qrId}|${expiresAt}`)
                         .digest('hex');
  
  // 存储到Redis
  await redis.set(`qrcode:${qrId}`, JSON.stringify({
    status: 'pending', // pending/confirmed/expired
    userId: null,
    signature,
    expiresAt
  }), 'EX', 300); // 5分钟自动过期

  return {
    qrId,
    expiresAt,
    signature,
    qrCodeUrl: `https://api.example.com/qr?data=${encodeURIComponent(JSON.stringify({qrId, signature}))}`
  };
};
```
手机端扫码处理
```
// Android扫码处理示例
public void handleQRCodeScan(String qrData) {
  JSONObject data = new JSONObject(qrData);
  String qrId = data.getString("qrId");
  String signature = data.getString("signature");
  
  // 验证签名
  String computedSig = HmacSHA256(qrId + "|" + data.getLong("expiresAt"), SECRET);
  if(!computedSig.equals(signature)) {
    showToast("二维码已失效");
    return;
  }
  
  // 检查登录状态
  if(!isUserLoggedIn()) {
    startLoginFlow();
    return;
  }
  
  showConfirmationDialog(qrId);
}

// 确认授权
private void confirmAuthorization(String qrId) {
  String token = getAuthToken();
  ApiClient.post("/auth/confirm", new JSONObject()
      .put("qrId", qrId)
      .put("token", token))
      .enqueue(new Callback() {
        public void onResponse(Response response) {
          showToast("登录成功");
        }
      });
}
```
服务端状态管理
```
# 二维码状态管理API
@app.route('/auth/confirm', methods=['POST'])
def confirm_auth():
    data = request.json
    qr_id = data['qrId']
    user_token = data['token']
    
    # 验证二维码状态
    qr_data = redis.get(f'qrcode:{qr_id}')
    if not qr_data:
        return {'code': 404, 'msg': '二维码已过期'}
    
    qr_info = json.loads(qr_data)
    if qr_info['status'] != 'pending':
        return {'code': 400, 'msg': '二维码已使用'}
    
    # 验证用户Token
    user_id = verify_user_token(user_token)
    if not user_id:
        return {'code': 401, 'msg': '用户未登录'}
    
    # 更新状态
    qr_info['status'] = 'confirmed'
    qr_info['userId'] = user_id
    redis.set(f'qrcode:{qr_id}', json.dumps(qr_info), ex=60)  # 1分钟完成登录
    
    # 通知网页端
    websocket_server.push_message(qr_id, {
        'type': 'confirmed',
        'token': generate_web_token(user_id)
    })
    
    return {'code': 200, 'msg': '授权成功'}
```
网页端登录处理
```
// 网页端二维码处理
let socket = null;

function initQRLogin(qrId) {
  // 建立WebSocket连接
  socket = new WebSocket(`wss://api.example.com/qr-ws?qrId=${qrId}`);
  
  socket.addEventListener('message', (event) => {
    const data = JSON.parse(event.data);
    
    switch(data.type) {
      case 'connected':
        updateStatus('等待扫码...');
        break;
      case 'scanned':
        updateStatus('已扫码，等待确认...');
        break;
      case 'confirmed':
        completeLogin(data.token);
        break;
      case 'expired':
        showError('二维码已过期');
        generateNewQR();
        break;
    }
  });
}

function completeLogin(token) {
  // 用token交换登录凭证
  fetch('/api/login', {
    method: 'POST',
    body: JSON.stringify({ token })
  })
  .then(response => response.json())
  .then(data => {
    localStorage.setItem('authToken', data.accessToken);
    redirectToDashboard();
  });
}
```
### 扫码登录的重要性

扫码登录方案已在微信、支付宝等大型系统中验证，平均登录时间从传统的1分钟缩短至3秒内，转化率提升40%，同时安全性提升70%。

### 扫码登录的核心原理

扫码登录的实现原理核心是基于一个中转站，该中转站通常由应用提供商提供，用于维护手机和PC之间的会话状态。

### 整个扫码登录的流程
* 1.用户在PC端访问应用，并选择使用扫码登录方式。此时，应用生成一个随机的认证码，并将该认证码通过二维码的形式显示在PC端的页面上。
* 2.用户打开手机上的应用，并选择使用扫码登录方式。此时，应用会打开手机端的相机，用户可以对着PC端的二维码进行扫描。
* 3.一旦用户扫描了二维码，手机上的应用会向应用提供商的中转站发送一个请求，请求包含之前生成的随机认证码和手机端的一个会话ID。
* 4.中转站验证认证码和会话ID是否匹配，如果匹配成功，则该中转站将用户的身份信息发送给应用，并创建一个PC端和手机端之间的会话状态。
* 5.应用使用收到的身份信息对用户进行认证，并创建一个与该用户关联的会话状态。同时，应用返回-个通过认证的响应给中转站。
* 6.中转站将该响应返回给手机端的应用，并携带一个用于表示该会话的令牌，此时手机和PC之间的认证流程就完成了。
* 7.当用户在PC端进行其他操作时，应用将会话令牌附加在请求中，并通过中转站向手机端的应用发起请求。手机端的应用使用会话令牌(也就是之前生成的令牌)来识别并验证会话状态，从而允许用户在PC端进行需要登录的操作。
# 五、面试常问:为什么 Vite 速度比 Webpack 快?
## 原因：
Vite 在开发环境的速度优势主要源于其创新的 “按需编译”机制 和 “原生 ESM 支持” 的设计理念，与 Webpack 的“全量打包”模式形成鲜明对比。
* 1、开发模式的差异
  
  Webpack 是先打包再启动开发服务器，而 Vite 则是直接启动，然后再按需编译在开发环境中，依赖文件。(大家可以启动项目后检查源码 Sources 那里看到)这意味着，当使用 Webpack 时，所有的模块都需要在开发前进行打包，这会增加启动时间和构建时间

  vite 则采用了不同的策略，它会在请求模块时再进行实时编译，这种按需动态编译的模式极大地缩短了编译时间，特别是在大型项目中，文件数量众多，Vite的优势更为明显。、
  
webpack启动
<img width="1335" height="663" alt="image" src="https://github.com/user-attachments/assets/79f407bb-5718-4aa2-9c30-5c5f55bd3556" />
vite启动
<img width="1185" height="1071" alt="image" src="https://github.com/user-attachments/assets/9733de1c-15e6-474e-b497-94701f5870e2" />

* 2、模块处理方式

  现代浏览器本身就支持 ES Modules，会 主动发起 请求去获取所需文件。Vite充分利用了这一点，将开发环境下的模块文件直接作为浏览器要执行的文件，而不是像 Webpack那样 先打包 ，再交给浏览器执行。这种方式减少了中间环节，提高了效率。

  什么是ES Modules?

  通过使用 export 和 import 语句，ES Modules 允许在浏览器端导入和导出模块。当使用 ES Modules 进行开发时，开发者实际上是在构建一个 依赖关系图 ，不同依赖项之间通过导入语句进行关联。主流浏览器(除IE外)均支持ES Modules，并且可以通过在script标签中设置 type="module"来加载模块。默认情况下，模块会延迟加载，执行时机在文档解析之后，触发DOMContentLoaded事件前。

  浏览器角色转变：Vite 将浏览器变为“合作者”，而非被动接收打包结果的“消费者”
  
  Webpack
  
  模块加载  模拟模块系统（__webpack_require__），需打包合并文件   
  调试体验  代码为打包后形态，调试需 Source Map 映射
  
  vite
  
  模块加载  浏览器直接加载 ESM 模块，减少中间转换环节
  调试体验  浏览器运行原始源码，调试更直观
<img width="1179" height="432" alt="image" src="https://github.com/user-attachments/assets/b0b01420-e043-4f82-b4aa-9b3c589f6edf" />

  * 3、底层语言的差异

    Webpack是基于 Node.js 构建的，而Vite 则是基于 esbuild 进行预构建依赖。esbuild 是采用 Go 语言编写的，Go 语言是 纳秒 级别的，而 Node.is是 毫秒 级别的。因此，Vite 在打包速度上相比Webpack有 10-100 倍的提升。

    什么是预构建依赖?

    预构建依赖通常指的是在项目 启动或构建 之前，对项目中所需的依赖项进行预先的 处理或构建 。这样做的好处在于，当项目实际运行时，可以 直接使用 这些已经预构建好的依赖，而无需再进行实时的编译或构建，从而提高了应用程序的运行速度和效率。

  * 4、热更新的处理

    在 Webpack 中，当一个模块或其依赖的模块内容改变时，需要 重新编译 这些模块。而在 Vite 中，当某个模块内容改变时，只需要让浏览器 重新请求 该模块即可，这大大减少了热更新的时间

## 总结

总的来说，Vite 之所以比 Webpack 快，主要是因为它采用了 不同的开发模式充分利用了现代浏览并优化了热更新的处理 。这些特点使得器的 ES Modules 支持、使用了更高效的底层语言Vite在大型项目中具有显著的优势，能够快速启动和构建，提高开发效率。

## 面试回答精要
Vite 的核心优势是 开发阶段免打包：
  * 按需编译：浏览器通过 ESM 按需请求文件，Vite 仅实时编译当前模块
  * 依赖预构建：用 Go 语言 esbuild 预编译第三方库，速度提升 10-100 倍
  * 热更新机制：基于 ESM 的 HMR 仅更新单文件，毫秒级响应。代价是生产环境需切 Rollup，且对旧浏览器支持较弱

通过以上机制，Vite 在开发阶段实现了质的速度飞跃，尤其适合现代框架（Vue/React）的快速迭代场景。而 Webpack 在深度定制和兼容性场景仍不可替代

# 六、为什么⼤⼚都要开发⾃⼰的脚⼿架？
预开发环节 ⇒ 开发环节 ⇒ 构建环节 ⇒ 预提交环节 ⇒ 发布环节
## 预开发环节
### 简化命令与配置
在没有脚⼿架的时候，我们是怎么配置⼀个项⽬的呢？我们需要在项⽬中创建wekpack.config.js /
rollup.config.js⽂件，基于开发和⽣产环境做各⾃的配置。
如果⽤到了⼀些别的⼯具，如esbuild等，⼜得增加⼀个别的配置⽂件，⽽像eslint、prettier、jest这
些也都有各⾃的配置⽂件。⽽具体使⽤的时候，各个⼯具⼜各⾃需要各⾃的命令。
每次都记这⼀堆命令和配置对开发者来说是⼀件⾮常⿇烦的事情，这也是脚⼿架对开发者来说最⼤的
意义，它能够很⼤程度上简化我们需要的命令和配置。
⽽我们是怎么使⽤脚⼿架的呢？拿vite为例，我们可以通过简单的命令就创建出⼀个vite的项⽬。
输⼊命令⾏，进⾏⼀些选择就可以创建⼀个项⽬，不需要你去写⼀⼤堆的配置⽂件，直接 npm run
dev 就能跑起来；同时，直接 npm run build 就可以打包成⽣产环境的代码。如果是⼤⼚内部的
框架，甚⾄还可以集成⼤⼚内部的部署环境，跑⼀个 npm run preview 或者 npm run deploy
就可以预览 / 部署。
如果我们要实现这样的效果，⾸先我们需要在脚⼿架项⽬中预定义⼀些模板（类似react、react-ts、
vue、vue-ts等），其次，我们要能在命令⾏中运⾏bin来进⾏项⽬创建，可以看看vite的源码，在
create-vite的package.json中
```
1 export async function resolveConfig(
2 inlineConfig: InlineConfig,
3 command: 'build' | 'serve',
4 defaultMode = 'development'
5 ): Promise<ResolvedConfig> {
6 let config = inlineConfig
7 let configFileDependencies: string[] = []
8 let mode = inlineConfig.mode || defaultMode
9
10 // some dependencies e.g. @vue/compiler-* relies on NODE_ENV for getting
11 // production-specific behavior, so set it here even though we haven't
12 // resolve the final mode yet
13 if (mode === 'production') {
14 process.env.NODE_ENV = 'production'
15 }
16 .
```
## 开发环节
### 提供模板
脚⼿架可提供多套模板供⽤⼾选择，类似纯js、纯ts、vue3+ts。同时，对于⼀些⽹⻚需要的通⽤配置
元素，如favicon，title，preconnect link可以通过config的⽅式提供给⽤⼾配置。
也可以先提供monorepo壳⼦的模板，在其中再进⾏项⽬的初始化。
### 约定式路由
在项⽬中，可以约定⼀个名为pages的⽂件夹，pages下的⽂件夹中的index默认为⼀个个page。在
pages中如果给出404、500这样的index，也可以⽅便地做⼀些做⻚⾯错误catch的处理；并且可以在
脚⼿架中默认集成动态引⼊组件。
在需要做单⻚⾯维度的权限校验的场景下，这时⼜分两种提⽰⽅式：第⼀种是不该进的路由⽤⼾⽆法
进⼊，第⼆种是可以进⼊，但是给⼀个申请权限的弱提⽰。如果是想要第⼀种提⽰⽅式的话，约定式
路由需要进⼊⻚⾯后校验没有权限再跳出，体验上会稍差⼀些。
### 集合微前端
现在的single-spa、qiankun等微前端框架都⾮常流⾏，脚⼿架可以提供⼀套有微前端框架的B端模
板，直接⽤于给开发者⽣成。如果是在⼤公司内部，往往对这些微前端框架本⾝也有⼀定的封装，形
成公司⾃⼰的微前端框架，但对于脚⼿架来说，做的事情还是⼀样的，就是把微前端框架的部分封装
起来。在开发者使⽤的时候，开发者甚⾄不需要知道⻚⾯是通过微前端的⽅式来加载的，就⽤普通写
组件的⽅式来写就好。
### 提供可插拔的功能插件（权限、埋点、sentry等
脚⼿架可提供⼀些插件，供开发者选择是否接⼊（插件和上part提到的feature flag各⾃的侧重点是：
通过feature flag提供的功能更多与构建相关，⽽插件更多为开发以及⼀些附加平台功能）。像是埋
点、sentry都⽐较简单好理解，我们这⾥来聊⼀下权限。
⼤⼚尤其是内部系统很多都是使⽤单点登录进⾏登录的，⽽如果访问接⼝没有权限⼀般会是401的错误
码，所以其实可以在权限插件中做统⼀的⽆权限的登录跳转。
权限插件还可以做再细致的权限校验，我们可以结合menu封装，对每⼀个⻚⾯进⾏业务逻辑上的可⻅
的设置。
### ⽹络请求层⾯封装
脚⼿架⼀般会根据当前的运⾏环境进⾏⽹络请求⽅⾯的配置，⽐如dev、test、pre-release、
production等，因为不同环境的请求baseURL、超时时间会不同。
同时，脚⼿架还可以提供基于接⼝定义⽣成接⼝定义代码的功能，通过后端提供的swagger/thrift⽂件
直接⽣成接⼝请求代码。
### prettier、eslint
每个⼤⼚都会有⾃⼰对prettier和eslint的要求，将prettier和eslint的配置可以统⼀收⼝在脚⼿架中，
形成⼀套代码⻛格。
## 构建环节
### 构建打包⽀持
脚⼿架往往提供开箱即⽤的构建打包⼯具⽀持，对于前端常⻅的⽂件类型提供了默认配置，⼀般包
括：
1. ts、js
2. css / less / sass / stylus / postcss / css module / tailwind⽀持，有的脚⼿架甚⾄提供了默认的换
肤配置
3. 图⽚、svg（包括导⼊为src或组件直接渲染）
4. wasm等等
### 避免重复造轮⼦
这⾥的重复造轮⼦更多指的是性能优化层⾯，⾸先脚⼿架⼀般都有持续迭代的同学，当新技术出来时
（⽐如vite、esbuild、swc等），可以先进⾏⼀波升级并推出beta版本或者提供出⼀个feature flag，
减少真正产出业务的同学重复踩坑的可能。
## 预提交环节
### commit hook
脚⼿架中可以集成git commit之前触发的钩⼦，钩⼦中主要可以做：
1. commit message的check，例如项⽬是monorepo结构，那commit message应该是
feat/fix/choreRR(project name): xxx改动，可以采⽤commitlint - Lint commit messages
2. 代码质量的初步校验，eslint、prettier的强校验
这⾥不建议在commit hook中做过于重的校验，因为commit时希望hook能够较快执⾏完，让⽤⼾还
是可以尽快提交。更全的校验还是放在CI阶段执⾏，如unit test等
## 发布环节
### push结合CI
在预提交环节，我们提到了⽤commit hook做初步校验，但是hook总是有⽅法绕过的，所以在CI时还
是要做double-check。
⼀般脚⼿架会提供⼀个ci yml⽂件来灵活的控制构建，在push代码可以进⾏CI，⼀旦CI有问题后续的
合⼊或者CD都不可再继续。
发正式版本可以在本地⽤脚⼿架publish，也可以在画⾯CI时直接提供打正式包的选项。

## 总结
通用脚手架（如 create-react-app, vue-cli, Vite）是优秀的、面向广泛社区的工具，但它们的设计目标是通用性和灵活性。对于拥有庞大技术团队、严格规范要求、复杂基础设施和特定技术栈的大厂来说，这些工具往往需要大量的二次配置和改造才能满足内部需求，反而降低了效率
### 自研脚手架的核心价值在于
* 标准化与一致性： 强制执行最佳实践和规范，消除项目间差异。
* 极致提效： 一键生成符合所有要求的基础项目，开发者聚焦业务开发。
* 深度集成： 无缝对接内部复杂的基础设施和工具链。
* 强控制力： 确保技术栈安全、稳定、可控。
虽然开发和维护自研脚手架需要投入成本，但对于大型技术组织而言，其在提升整体研发效能、保障工程质量、降低协作成本方面带来的收益是巨大的，远超过投入的成本。因此，自研脚手架成为大厂工程化体系建设中不可或缺的一环    


# 七、调试除了会console.log 还会些什么？
除了console.log() 外 还有console 的六种其他格式 
在日常开发中，大多数都会通过console.log 的方式来进行代码调试。但是console.1og 是具备很多局限性的，比如:我们想要获取某段代码的执行耗时，通过console.1og 就无法满足需求。
那么怎么办呢?其实对于 console 对象来说，除了 10g 方法它还提供了很多其他的方法帮助我们进行调试，利用这些方法可以极大地提升我们的工作效率
* console.table
  
  使用console.table可视化复杂的对象和数组
  ```
  const Data = [
     {
       name:"程序员Sunday",
       age:30
     },
     {
       name:"Sunday",
       age:25
     }
  ]

  ```
  打印结果如下
  
  <img width="1209" height="219" alt="image" src="https://github.com/user-attachments/assets/861a8988-88ed-4d68-a6ed-e5205b687e42" />

* console.trace
    使用console.trace 可以明确函数的调用逻辑关系
    ```
    function fn(){
       function test {
            console.trace('这是一个利用trace的测试打印')
        }
      test()
    }
    fn()
    ```
    打印结果如下
  
    <img width="801" height="174" alt="image" src="https://github.com/user-attachments/assets/ec6a97a5-e3db-4c8d-9acf-79907257035d" />

* console.time && console.timeEnd
    
   利用 console.time && console.timeEnd 来记录代码的执行耗时：
   ```
   console.time('js耗时')
   const vNodes = []
   for (let i = 0;i< 10000;i++){
     const vNode = {
       type:'div'
     }
     vNodes.push(vNode)
   }
   console.timeEnd('js耗时')
   ```
   打印结果如下
  
   <img width="771" height="75" alt="image" src="https://github.com/user-attachments/assets/270d389c-d533-480d-8567-02d07a2f988a" />

* console.assert
  
  使用console.assert 断言你的判断luoji
  如果断言为假，它抛出一个你指定的错误
  ```
  const myArray = []
  console.assert(myArray.length>0,'myArray是空的！')
  ```
  打印结果如下：
  
  <img width="738" height="99" alt="image" src="https://github.com/user-attachments/assets/0e79f1e9-a6a7-4fa3-a2d3-f50eaaca71fd" />

* console.clear
  
  在很多时候，我们的控制台可能会打印非常多的内容。所以，可以让代码在执行到某一个特定的时机时，利用console.clear()清空控制台
  ```
  console.clear()
  ```

* console.error
  
  使用 console.error 直接打印一个错误级别的描述
  ```
  console.error('错误信息')
  ```
  打印结果如下：
  
  <img width="528" height="108" alt="image" src="https://github.com/user-attachments/assets/41230418-98ca-4d88-b98d-763db577ee3a" />

# 八、说下你的vue项目的目录结构，如果是大型项目你应该划分结构和划分组件呢？
## 1、为什么要划分？
使用vue构建项目，项目结构会提高开发效率，熟悉项目的各种配置同样会使开发效率更高
在划分项目结构的时候 需要遵循一些基本的原则：
* 文件夹和文件夹内部的语义一致性
* 单一入口/出口
* 就近原则，紧连接的文件应该放在一起，且应以相对路径引用在一起
* 公共的文件应该以绝对路径的方式从根目录引用
* /src外部的文件不应该被引入

具体

### 文件夹和文件夹内部文件的语义一致性
我们的目录结构都会有一个文件夹是按照路由模块来划分的，比如pages文件夹，这个文件夹里面应该包含我们项目所有的路由模块，而不应该有其他其他的非路由模块的文件夹
### 单一入口/出口
比如：在pages文件夹里面存在一个seller文件，这个时候seller文件夹应该作为一个独立的模块应该由外部引入，并且seller/index.js作为外部引入卖家模块的唯一入口
```
// 错误用法
import sellerReducer from 'src/pages/seller/reducer'

// 正确用法
import { reducer as sellerReducer } from 'src/pages/seller'
```
这样的好处就是 无论你的模块文件夹内部有多乱，外部引用的时候，都是从一个入口文件引入，这样就很好的实现了隔离
如果后续有重构需求，你就会发现这种方式的优点
### 就近原则，紧连接的文件应该放在一起，且应以相对路径引用在一起
使用相对路径可以保证模块内部的独立性
```
// 正确用法
import styles from './index.module.scss'
// 错误用法
import styles from 'src/pages/seller/index.module.scss'
```
假设我们现在的卖家目录在src/pages/seller，如果我们后续发生了路由变更，需要加一个系统，变成src/pages/user/seller。

如果我们采用第一种相对路径的方式，那么可以直接将整个文件夹拖过去就好，seller文件夹内部不需要做任何变更。

但是如果我们采用修改第二个绝对路径的方式，移动文件夹的同时，还需要对每个的import路径做

### 公共的文件应该以绝对路径的方式从根目录引用

公共指的是多个路由模块占用，如一些公共的组件，我们可以放在src/components下

在使用到的页面中，采用绝对路径的形式引用的，如果我们对文件夹结构进行调整。将需要/src/components/input变成/src/components/new/input，如果使用绝对路径，只需要全局搜索替换同样，再加上绝对路径有全局的语义，相对路径有独立模块的语义

```
// 错误用法
import Input from '../../components/input'
// 正确用法
import Input from 'src/components/input'
```
### /src 外部的文件不应该被引入
vue-cli脚手架已经帮我们做了相关的约束了，正常我们的引入项目都会有一个文件src夹，里面放着所有的项目需要的资源，，，，js等等。外面会放一些项目配置，依赖，环境等 css文件pngsvgsrc
这样的好处是方便划分项目代码文件和配置文件
## 2、目录结构
单页面目录结构
```
project
│  .browserslistrc
│  .env.production
│  .eslintrc.js
│  .gitignore
│  babel.config.js
│  package-lock.json
│  package.json
│  README.md
│  vue.config.js
│  yarn-error.log
│  yarn.lock
│
├─public
│      favicon.ico
│      index.html
│
|-- src
    |-- components
        |-- input
            |-- index.js
            |-- index.module.scss
    |-- pages
        |-- seller
            |-- components
                |-- input
                    |-- index.js
                    |-- index.module.scss
            |-- reducer.js
            |-- saga.js
            |-- index.js
            |-- index.module.scss
        |-- buyer
            |-- index.js
        |-- index.js
```
多页面目录结构
```
my-vue-test:.
│  .browserslistrc
│  .env.production
│  .eslintrc.js
│  .gitignore
│  babel.config.js
│  package-lock.json
│  package.json
│  README.md
│  vue.config.js
│  yarn-error.log
│  yarn.lock
│
├─public
│      favicon.ico
│      index.html
│
└─src
    ├─apis //接口文件根据页面或实例模块化
    │      index.js
    │      login.js
    │
    ├─components //全局公共组件
    │  └─header
    │          index.less
    │          index.vue
    │
    ├─config //配置（环境变量配置不同passid等）
    │      env.js
    │      index.js
    │
    ├─contant //常量
    │      index.js
    │
    ├─images //图片
    │      logo.png
    │
    ├─pages //多页面vue项目，不同的实例
    │  ├─index //主实例
    │  │  │  index.js
    │  │  │  index.vue
    │  │  │  main.js
    │  │  │  router.js
    │  │  │  store.js
    │  │  │
    │  │  ├─components //业务组件
    │  │  └─pages //此实例中的各个路由
    │  │      ├─amenu
    │  │      │      index.vue
    │  │      │
    │  │      └─bmenu
    │  │              index.vue
    │  │
    │  └─login //另一个实例
    │          index.js
    │          index.vue
    │          main.js
    │
    ├─scripts //包含各种常用配置，工具函数
    │  │  map.js
    │  │
    │  └─utils
    │          helper.js
    │
    ├─store //vuex仓库
    │  │  index.js
    │  │
    │  ├─index
    │  │      actions.js
    │  │      getters.js
    │  │      index.js
    │  │      mutation-types.js
    │  │      mutations.js
    │  │      state.js
    │  │
    │  └─user
    │          actions.js
    │          getters.js
    │          index.js
    │          mutation-types.js
    │          mutations.js
    │          state.js
    │
    └─styles //样式统一配置
        │  components.less
        │
        ├─animation
        │      index.less
        │      slide.less
        │
        ├─base
        │      index.less
        │      style.less
        │      var.less
        │      widget.less
        │
        └─common
                index.less
                reset.less
                style.less
                transition.less
```
## 总结：
项目的目录结构很重要，目录结构能够体现很多东西，怎么规划目录结构可能每个人都有自己的理解，但是按照一定的规范去进行目录的设计，让项目整个架构看起来更简洁，更容易掌握 大型项目的核心是 通过分层和模块化控制复杂度

# 九、SSR解决了什么问题？有自己SSR吗？你是怎么做的？
## 1、SSR是什么？
Sever-Side Rendering 我们称为SSR，意为服务端渲染
指由服务侧完成页面HTML结构拼接的页面处理技术，发送到浏览器，然后简单地绑定状态与事件，成为完全可交互页面的过程
web3个阶段的发展史：
* 传统服务端渲染SSR
* 单页面应用SPA
* 服务端渲染SSR
## 传统的网络开发
网页内容在服务端渲染完成，统一次性传输到浏览器
<img width="657" height="705" alt="image" src="https://github.com/user-attachments/assets/5d8bb959-ed46-44cf-816f-2710ef760cf1" />
打开页面查看源码，浏览器获得了全部的dom结构
## 单页面应用 SPA
单页应用优秀的用户体验，布局逐渐成为主流，页面内容由js渲染出来，这种方式称为客户端渲染
<img width="659" height="745" alt="image" src="https://github.com/user-attachments/assets/a2760a34-fa43-4339-a390-791e99335083" />
打开页面查看源码，浏览器获得了首先元素#app，并没有内容
## 服务端渲染 SSR
SSR解决方案，支架渲染出完整的首屏的dom结构返回，前端获取的内容包括首屏及完整的spa结构，应用激活后依然按照spa方式运行 
<img width="649" height="571" alt="image" src="https://github.com/user-attachments/assets/7bf381e0-4338-4223-b2e9-48be9b40abe3" />
## Vue官方对SSR的解释：
Vue.js 是构建客户端应用程序的框架。这种情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。但是，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们默认直接发送到浏览器，最后将这些静态标记“激活”为客户端上可交互的应用程序

服务器渲染的 Vue.js 应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行

我们从上面解释得到以下结论：
* Vue SSR是一个SPA正在进行改进的服务端渲染
* 通过Vue SSR 渲染的页面，需要在客户端激活才能实现交互
* Vue SSR 将包含两个部分：服务端渲染的首屏，交互包含的SPA
## 2、解决了什么
SSR 主要解决了以下两个问题：
* SEO：引擎搜索优先爬取页面HTML结构，使用SSR时，服务端已经生成了和业务相关联的HTML，有利于SEO
* 首屏呈现渲染：用户等待页面所有js加载完成就可以看到页面视图压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交互客户端
使用SSR同时存在以下缺点：
* 复杂度：整个项目的复杂度
* 库的支持性，代码兼容
* 性能问题
  * 每个请求都是n一个实例的创建，不然会消耗，消耗会很大
  * 缓存node serve、ngin x 判断用户当前有没有过期，如果没有过期的话就缓存，用刚才的结果
  * 降级：监控cpu、内存占用过多，就SPA，返回单个的壳
* 服务器负载变大，相对于前服务器只需要提供静态资源来说，服务器负载更大，使用要慎重使用
所以在我们选择是否要使用SSR之前，我们需要仔细审视自己这些问题
1.需要SEO的页面是否只是少数，这些是否可以使用预渲染Prerender SPA Plugin实现
2.主屏的请求响应逻辑是否复杂，数据是否返回大量且缓慢
## 3、如何实现
对于同构开发，我们仍然使用webpack资源，我们要解决两个问题：服务端首屏渲染和客户端激活

这里需要生成一个服务器bundle文件用于服务端首屏渲染和一个客户端bundle文件用于客户端激活

代码结构除了两个不同的入口之外，其他结构和之前的vue应用均

```
src
├── router
├────── index.js # 路由声明
├── store
├────── index.js # 全局状态
├── main.js # ⽤于创建vue实例
├── entry-client.js # 客户端⼊⼝，⽤于静态内容“激活”
└── entry-server.js # 服务端⼊⼝，⽤于⾸屏内容渲染
```

路由配置

```
import Vue from "vue";
import Router from "vue-router";

Vue.use(Router);
//导出⼯⼚函数

export function createRouter() {
    return new Router({
        mode: 'history',
        routes: [
            // 客户端没有编译器，这⾥要写成渲染函数
            { path: "/", component: { render: h => h('div', 'index page') } },
            { path: "/detail", component: { render: h => h('div', 'detail page') } }
        ]
    });
}
```
主文件main.js

跟之前不同，主文件是负责创建vue实例的工厂，每次请求都会有独立的vue实例创建

```
import Vue from "vue";
import App from "./App.vue";
import { createRouter } from "./router";
// 导出Vue实例⼯⼚函数，为每次请求创建独⽴实例
// 上下⽂⽤于给vue实例传递参数
export function createApp(context) {
    const router = createRouter();
    const app = new Vue({
        router,
        context,
        render: h => h(App)
    });
    return { app, router };
}
```

编写服务端入口src/entry-server.js

它的任务是创建Vue实例并根据确定url的指定首屏

```
import { createApp } from "./main";
// 返回⼀个函数，接收请求上下⽂，返回创建的vue实例
export default context => {
    // 这⾥返回⼀个Promise，确保路由或组件准备就绪
    return new Promise((resolve, reject) => {
        const { app, router } = createApp(context);
        // 跳转到⾸屏的地址
        router.push(context.url);
        // 路由就绪，返回结果
        router.onReady(() => {
            resolve(app);
        }, reject);
    });
};
```
编写客户端入口entry-client.js

客户端只需创建vue实例并执行挂载，这一步称为激活

```
import { createApp } from "./main";
// 创建vue、router实例
const { app, router } = createApp();
// 路由就绪，执⾏挂载
router.onReady(() => {
    app.$mount("#app");
});
```

对webpack进行配置

安装依赖

```
npm install webpack-node-externals lodash.merge -D
```

对vue.config.js进行配置

```
// 两个插件分别负责打包客户端和服务端
const VueSSRServerPlugin = require("vue-server-renderer/server-plugin");
const VueSSRClientPlugin = require("vue-server-renderer/client-plugin");
const nodeExternals = require("webpack-node-externals");
const merge = require("lodash.merge");
// 根据传⼊环境变量决定⼊⼝⽂件和相应配置项
const TARGET_NODE = process.env.WEBPACK_TARGET === "node";
const target = TARGET_NODE ? "server" : "client";
module.exports = {
    css: {
        extract: false
    },
    outputDir: './dist/'+target,
    configureWebpack: () => ({
        // 将 entry 指向应⽤程序的 server / client ⽂件
        entry: `./src/entry-${target}.js`,
        // 对 bundle renderer 提供 source map ⽀持
        devtool: 'source-map',
        // target设置为node使webpack以Node适⽤的⽅式处理动态导⼊，
        // 并且还会在编译Vue组件时告知`vue-loader`输出⾯向服务器代码。
        target: TARGET_NODE ? "node" : "web",
        // 是否模拟node全局变量
        node: TARGET_NODE ? undefined : false,
        output: {
            // 此处使⽤Node⻛格导出模块
            libraryTarget: TARGET_NODE ? "commonjs2" : undefined
        },
        // https://webpack.js.org/configuration/externals/#function
        // https://github.com/liady/webpack-node-externals
        // 外置化应⽤程序依赖模块。可以使服务器构建速度更快，并⽣成较⼩的打包⽂件。
        externals: TARGET_NODE
        ? nodeExternals({
            // 不要外置化webpack需要处理的依赖模块。
            // 可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件，
            // 还应该将修改`global`（例如polyfill）的依赖模块列⼊⽩名单
            whitelist: [/\.css$/]
        })
        : undefined,
        optimization: {
            splitChunks: undefined
        },
        // 这是将服务器的整个输出构建为单个 JSON ⽂件的插件。
        // 服务端默认⽂件名为 `vue-ssr-server-bundle.json`
        // 客户端默认⽂件名为 `vue-ssr-client-manifest.json`。
        plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new
                  VueSSRClientPlugin()]
    }),
    chainWebpack: config => {
        // cli4项⽬添加
        if (TARGET_NODE) {
            config.optimization.delete('splitChunks')
        }

        config.module
            .rule("vue")
            .use("vue-loader")
            .tap(options => {
            merge(options, {
                optimizeSSR: false
            });
        });
    }
};
```

对脚本进行配置，安装依赖

```
npm i cross-env -D
```

定义脚本package.json

```
"scripts": {
 "build:client": "vue-cli-service build",
 "build:server": "cross-env WEBPACK_TARGET=node vue-cli-service build",
 "build": "npm run build:server && npm run build:client"
}
//执行资源：npm run build
```

最后修改文件/public/index.html

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <!--vue-ssr-outlet-->
    </body>
</html>
//是服务端渲染入口位置，注意不能为了美观而在前后加空格
```

安装vuex

```
npm install -S vuex
```

创建vuex工厂函数

```
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
export function createStore () {
    return new Vuex.Store({
        state: {
            count:108
        },
        mutations: {
            add(state){
                state.count += 1;
            }
        }
    })
}
```

在main.js文件中挂载store

```
import { createStore } from './store'
export function createApp (context) {
    // 创建实例
    const store = createStore()
    const app = new Vue({
        store, // 挂载
        render: h => h(App)
    })
    return { app, router, store }
}
```

服务器端渲染是应用程序的“快照”，如果应用依赖于一些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据

进行store下一步数据获取

```
export function createStore() {
    return new Vuex.Store({
        mutations: {
            // 加⼀个初始化
            init(state, count) {
                state.count = count;
            },
        },
        actions: {
            // 加⼀个异步请求count的action
            getCount({ commit }) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        commit("init", Math.random() * 100);
                        resolve();
                    }, 1000);
                });
            },
        },
    });
}
```

组件中的数据预取逻辑

```
export default {
    asyncData({ store, route }) { // 约定预取逻辑编写在预取钩⼦asyncData中
        // 触发 action 后，返回 Promise 以便确定请求结果
        return store.dispatch("getCount");
    }
};
```

服务端数据预取，entry-server.js

```
import { createApp } from "./app";
export default context => {
    return new Promise((resolve, reject) => {
        // 拿出store和router实例
        const { app, router, store } = createApp(context);
        router.push(context.url);
        router.onReady(() => {
            // 获取匹配的路由组件数组
            const matchedComponents = router.getMatchedComponents();

            // 若⽆匹配则抛出异常
            if (!matchedComponents.length) {
                return reject({ code: 404 });
            }

            // 对所有匹配的路由组件调⽤可能存在的`asyncData()`
            Promise.all(
                matchedComponents.map(Component => {
                    if (Component.asyncData) {
                        return Component.asyncData({
                            store,
                            route: router.currentRoute,
                        });
                    }
                }),
            )
                .then(() => {
                // 所有预取钩⼦ resolve 后，
                // store 已经填充⼊渲染应⽤所需状态
                // 将状态附加到上下⽂，且 `template` 选项⽤于 renderer 时，
                // 状态将⾃动序列化为 `window.__INITIAL_STATE__`，并注⼊ HTML
                context.state = store.state;

                resolve(app);
            })
                .catch(reject);
        }, reject);
    });
};
```

客户端在挂载到应用程序之前，store就应该获取到状态，entry-client.js

```
// 导出store
const { app, router, store } = createApp();
// 当使⽤ template 时，context.state 将作为 window.__INITIAL_STATE__ 状态⾃动嵌⼊到最终的 HTML 
// 在客户端挂载到应⽤程序之前，store 就应该获取到状态：
if (window.__INITIAL_STATE__) {
    store.replaceState(window.__INITIAL_STATE__);
}
```

客户端数据预取处理，main.js

```
Vue.mixin({
    beforeMount() {
        const { asyncData } = this.$options;
        if (asyncData) {
            // 将获取数据操作分配给 promise
            // 以便在组件中，我们可以在数据准备就绪后
            // 通过运⾏ `this.dataPromise.then(...)` 来执⾏其他任务
            this.dataPromise = asyncData({
                store: this.$store,
                route: this.$route,
            });
        }
    },
});
```

修改服务器启动文件

```
// 获取⽂件路径
const resolve = dir => require('path').resolve(__dirname, dir)
// 第 1 步：开放dist/client⽬录，关闭默认下载index⻚的选项，不然到不了后⾯路由
app.use(express.static(resolve('../dist/client'), {index: false}))
// 第 2 步：获得⼀个createBundleRenderer
const { createBundleRenderer } = require("vue-server-renderer");
// 第 3 步：服务端打包⽂件地址
const bundle = resolve("../dist/server/vue-ssr-server-bundle.json");
// 第 4 步：创建渲染器
const renderer = createBundleRenderer(bundle, {
    runInNewContext: false, // https://ssr.vuejs.org/zh/api/#runinnewcontext
    template: require('fs').readFileSync(resolve("../public/index.html"), "utf8"), // 宿主⽂件
    clientManifest: require(resolve("../dist/client/vue-ssr-clientmanifest.json")) // 客户端清单
});
app.get('*', async (req,res)=>{
    // 设置url和title两个重要参数
    const context = {
        title:'ssr test',
        url:req.url
    }
    const html = await renderer.renderToString(context);
    res.send(html)
})
```

## 总结
* 使用ssr不存在单一实例模式，每次用户请求都会创建一个新的vue实例
* 实现ssr需要实现服务端首屏渲染和客户端激活
* 服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取
  * 第一屏异步获取数据，在服务端预渲染的时候就应该已经完成
  * 通过混入切换组件mixin，在beforeMount钩子中完成数据获取
 
## 回答
SSR（Server-Side Rendering）主要是为了解决传统纯客户端渲染SPA应用的两个核心痛点：首屏加载性能和SEO友好性
在纯CSR中，用户首次访问需要先下载一个较大的JavaScript包，然后由浏览器执行JS来渲染页面，这会导致明显的白屏时间，影响用户体验，尤其是在慢网络环境下
同时，搜索引擎爬虫可能无法有效执行JavaScript，导致抓取到的页面内容为空或不完整，对SEO非常不友好
SSR通过在Node.js服务器端运行前端框架，预先将React/Vue组件渲染成包含实际数据的完整HTML字符串。服务器直接将这个HTML发送给浏览器
这样，浏览器能立即展示出内容，极大缩短了白屏时间，提升了首屏加载速度
搜索引擎爬虫也能直接获取到完整的页面内容，解决了SEO问题
即使在JavaScript加载失败或被禁用的场景下，用户也能看到基本的页面结构
当然，SSR也带来了一些挑战，比如增加了服务器负载和架构的复杂度，但它确实在需要快速首屏和良好SEO的场景下提供了关键优势
