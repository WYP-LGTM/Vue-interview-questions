# 前端场景题
## 一、SPA首屏加载速度慢的怎么解决
### SPA首屏加载从5s优化到1s内，你会怎么做？
* 首屏性能优化需从资源加载、渲染路径、架构设计三方面切入
  * 1. 资源体积压缩（核心瓶颈）
     * 代码分割：路由级懒加载（React.lazy + Suspense） + 组件级动态导入（减少主包30%~50%）
     * 资源优化：
        * 图片转WebP并CDN分发（体积降40%）
        * 字体图标替代图片，关键CSS内联
        * 第三方库按需引入（如lodash-es替代lodash）
   * 2.  渲染提速
        *  流式SSR：Node.js分块输出HTML（React：renderToNodeStream），使首屏内容快速到达
        *  边缘计算：将SSR部署至CDN边缘节点（Vercel Edge Functions），降低网络延迟
        *  占位策略：骨架屏 + 图片懒加载（Intersection Observer API）、
   * 3. 网络与缓存优化
        * HTTP/2多路复用 + 资源预加载（<link rel="preload">）
        * Service Worker缓存静态资源，支持离线访问
        * 长期缓存：文件名添加contenthash（Webpack配置）
   * 4.  性能监测
        *  Lighthouse分析FCP/FID指标，Webpack Bundle Analyzer诊断包依赖
        *  线上监控：RUM（Real User Monitoring）采集3G网络/低端机数据
## 二、如果有100个请求，你如何使用Promise控制并发?
### 对于问题的解析-对问题的理解
当需要同时处理100个异步请求时，直接使用Promise.all会一次性发起所有请求，可能导致服务器过载或浏览器资源耗尽。我们需要实现一个并发控制机制，确保同时只有指定数量的请求在执行。
### 怎么来解决这个问题
* 在JavaScript中可以通过 Promise.all()、Promise.race()、async/await等不同方式来实现对异步并发任务的控制。
* 核心思路
  * 1.创建一个并发池--最大并发数
  * 2.动态添加请求到并发池
  * 3.当有请求完成时，从等待队列取出新请求执行
  * 4.所有请求完成后返回结果
### 示例代码
```
/**
 * 控制并发请求的函数
 * @param {Array} requests - 返回Promise的函数数组
 * @param {number} maxConcurrent - 最大并发数
 * @returns {Promise<Array>} - 包含所有请求结果的数组
 */
function concurrentControl(requests, maxConcurrent) {
  return new Promise((resolve) => {
    const results = new Array(requests.length); // 存储结果
    let completedCount = 0; // 已完成请求数
    let activeCount = 0;    // 当前活跃请求数
    let index = 0;          // 当前请求索引
    
    // 执行单个请求
    function run() {
      // 所有请求已完成
      if (completedCount === requests.length) {
        resolve(results);
        return;
      }
      
      // 并发池未满且有等待请求
      while (activeCount < maxConcurrent && index < requests.length) {
        const currentIndex = index; // 保存当前索引
        const request = requests[index];
        index++;
        activeCount++;
        
        // 执行请求并处理结果
        request()
          .then((res) => {
            results[currentIndex] = res;
          })
          .catch((err) => {
            results[currentIndex] = err;
          })
          .finally(() => {
            activeCount--;
            completedCount++;
            run(); // 完成一个请求后尝试执行下一个
          });
      }
    }
    
    run(); // 启动初始请求
  });
}
```
### 代码使用示例
```
// 模拟100个请求
const requests = [];
for (let i = 1; i <= 100; i++) {
  requests.push(() => {
    // 模拟不同延迟的请求
    const delay = Math.random() * 2000 + 500;
    return new Promise(resolve => {
      setTimeout(() => {
        console.log(`请求 ${i} 完成，耗时 ${delay.toFixed(0)}ms`);
        resolve(`结果 ${i}`);
      }, delay);
    });
  });
}

// 控制并发数为5
concurrentControl(requests, 5)
  .then(results => {
    console.log('所有请求完成：', results);
  });
```
### 实现原理
1.并发池管理:使用activeCount跟踪当前执行中的请求数量,使用maxConcurrent限制最大并发数 2.请求调度机制：当并发池有空位时，立即添加新请求,每个请求完成后，自动触发新请求加入 3.结果处理：使用闭包保存每个请求的索引位置,确保结果数组顺序与原始请求顺序一致 4.完成检测：通过completedCount跟踪已完成请求数量,当完成数等于总请求数时，返回最终结果
### 第三方库
例如 async.js 和 p-limit 等。 p-limit 是一个专门用于控制 Promise并发的小型库。可以在 p-limit 文档中找到更多信息和示例。
### 实现Promise并发控制的关键点
* 动态调度机制：在请求完成时立即启动新请求
* 精确的状态跟踪：维护活跃请求数和完成请求数
* 结果顺序保证：通过闭包保存原始索引位置
* 结果顺序保证：通过闭包保存原始索引位置
### 在面试中回答此问题时，应重点说明：
* 并发控制的必要性-避免服务器过载/资源耗尽
* 实现方案的核心思路-池化技术+动态调度
* 关键状态变量的作用-activeCount, completedCount
* 实际应用场景-图片批量上传、大数据分页加载等
### 如果想要面试高级前端工程所需要掌握
解决 100 个请求的并发控制，绝不仅仅是写一个简单的循环或递归。作为高级工程师，我会设计一个功能完备、健壮可靠、可配置可观测的异步任务调度器。它基于动态调度池的核心思想，并融入优先级、重试、超时、取消、进度反馈甚至自适应并发等高级特性，同时注重模块化、可测试性和生产环境监控。这样的方案才能真正应对复杂应用的挑战，保证系统的稳定性和用户体验。
### Promise并发控制的专业回答
* 系统设计
* 工程实践
* 性能优化
# 三、面试官问sessionStorage 能在多个标签页之间共享数据吗?
## sessionStorage能在多个标签页之间共享数据吗?
在回答这个问题之前我们先来聊聊另一个存储APl localstorage
只读的 localstorage 属性允许你访问一个 Document源(origin)的对象Storage ;存储的数据将保存在浏览器会话中。localstorage 类似 sessionstorage，但其区别在于:存储在1ocalstorage的数据可以长期保留;而当页面会话结束--也就是说，当页面被关闭时，存储在 sessionstorage 的数据会被清除。
### sessionStorage的底层机制

浏览器实例 ---> 标签1 --- >sessionStorage独立的存储桶 / ---> 标签2 --- >sessionStorage独立的存储桶
### 核心特性
localstorage
* 作用域--同源域名全局
* 数据共享--跨同源标签页
* 生命周期--永久存储
* 存储限制--通常5MB
* 数据同步--可通过storage事件同步

sessionStorage

* 作用域--单标签页级别
* 数据共享--仅限当前标签页
* 生命周期--标签页关闭即销毁
* 存储限制--通常5MB
* 数据同步--	无跨页同步机制
### 实现多标签页通信的解决方案
* LocalStorage + Storage 事件
原理：利用LocalStorage的全局性和storage事件广播
```
// 发送方标签页
function broadcastData(data) {
  localStorage.setItem('sharedData', JSON.stringify(data));
}

// 接收方标签页
window.addEventListener('storage', (event) => {
  if (event.key === 'sharedData') {
    const data = JSON.parse(event.newValue);
    console.log('收到数据:', data);
    
    // 处理数据后立即清理（可选）
    localStorage.removeItem('sharedData');
  }
});
```
* Broadcast Channel API---现代浏览器
原理：专门的跨标签页通信API
```
// 发送方
const channel = new BroadcastChannel('app-channel');
channel.postMessage({ type: 'dataUpdate', payload: data });

// 接收方
const channel = new BroadcastChannel('app-channel');
channel.onmessage = (event) => {
  console.log('收到广播:', event.data);
};
```
* SharedWorker 数据中转
原理：通过后台线程共享数据
```
// shared-worker.js
const connections = [];
onconnect = (e) => {
  const port = e.ports[0];
  connections.push(port);
  
  port.onmessage = (event) => {
    connections.forEach(conn => {
      if (conn !== port) conn.postMessage(event.data);
    });
  };
};

// 页面中使用
const worker = new SharedWorker('shared-worker.js');
worker.port.onmessage = (event) => {
  console.log('收到共享数据:', event.data);
};

// 发送数据
worker.port.postMessage({ key: 'theme', value: 'dark' });
```
### 安全与性能注意事项
安全防护要点
* 来源验证：所有跨页通信必须校验消息来源
* 数据消毒：严格验证传入数据结构
* 敏感数据加密：对token等敏感信息使用AES加密
性能优化建议
* 节流控制：高频数据更新使用节流
* 数据压缩：大型数据使用LZString压缩
* 差异更新：仅发送变化数据而非全量数据
### 问题回答
sessionStorage不能在多个窗口或标签页之间共享数据，但是当通过 window.open 或链接打开新页面时(不能是新窗口)，新页面会复制前一页的sessionStorage.
### 高级前端建议
对于关键业务数据共享，推荐使用BroadcastChannel API（兼容性允许时）或Redux+WebSocket的专业状态管理方案，避免直接依赖存储API实现核心业务逻辑同步。
